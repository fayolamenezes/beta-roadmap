<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clock Scroll Animation</title>
<style>
body {
  margin: 0;
  height: 400vh;
  background: #111;
  color: #fff;
  font-family: Arial, sans-serif;
}
.section {
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
}
.container {
  position: relative;
  width: 400px;
  height: 400px;
}
.dot {
  position: absolute;
  width: 15px;
  height: 15px;
  background: #D45427;
  transform: translate(-50%, -50%);
  opacity: 0;
}
.mini-dot {
  position: absolute;
  width: 5px;
  height: 5px;
  background: #fff;
  transform: translate(-50%, -50%);
  opacity: 0;
}

/* ✨ Floating pieces */
.floating-piece-main {
  position: absolute;
  background: #D45427;
  transform: translate(-50%, -50%);
  pointer-events: none;
}
.floating-piece-mini {
  position: absolute;
  background: #fff;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

.text {
  position: absolute;
  font-size: 16px;
  max-width: 200px;
  text-align: center;
  opacity: 0;
  transition: opacity 0.3s linear;
  line-height: 1.4em;
}
.hand {
  position: absolute;
  width: 15px;
  height: 160px;
  background: #fff;
  top: 50%;
  left: 50%;
  transform-origin: bottom center;
  transform: translate(-50%, -100%) rotate(0deg);
}
</style>
</head>
<body>
<div class="section">
  <div class="container" id="container">
    <div class="hand" id="hand"></div>

    <!-- Main dots + Labels -->
    <div class="dot" id="dot-top" style="top: 5%; left: 50%;"></div>
    <div class="text" style="top: calc(5% - 65px); left: 50%; transform: translateX(-50%);">
      Q1 2026 (Beta): Core SEO toolkit
    </div>

    <div class="dot" id="dot-right" style="top: 50%; left: 95%;"></div>
    <div class="text" style="top: 50%; left: calc(95% + 25px); transform: translateY(-50%);">
      Q2 2027+: Agency portal, expanded backlink suite
    </div>

    <div class="dot" id="dot-bottom" style="top: 95%; left: 50%;"></div>
    <div class="text" style="top: calc(95% + 15px); left: 50%; transform: translateX(-50%);">
      Q3 2026: Link Building + AI features
    </div>

    <div class="dot" id="dot-left" style="top: 50%; left: 5%;"></div>
    <div class="text" style="top: 50%; left: calc(5% - 215px); transform: translateY(-50%);">
      Q4 2026 (Public): Advanced analytics, competitor insights, integrations
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
<script>
gsap.registerPlugin(ScrollTrigger);

const container = document.getElementById("container");
const hand = document.getElementById("hand");

const mainDots = [
  document.getElementById("dot-top"),
  document.getElementById("dot-right"),
  document.getElementById("dot-bottom"),
  document.getElementById("dot-left")
];
const texts = document.querySelectorAll(".text");

const centerX = container.offsetWidth / 2;
const centerY = container.offsetHeight / 2;
const radius = 190;
const totalHeight = hand.offsetHeight;

// --- BUILD ALL DOTS (main + mini) ---
const allDots = [];
const mainAngles = [0, 90, 180, 270];

// main dots: 15px, type main
mainDots.forEach((dot, i) => {
  allDots.push({ el: dot, angle: mainAngles[i], size: 15, type: "main", text: texts[i] });
});

// mini dots: 10px, type mini
for (let i = 0; i < 16; i++) {
  if (i % 4 !== 0) {
    const angleDeg = i * 22.5;
    const rad = angleDeg * Math.PI / 180;
    const mini = document.createElement("div");
    mini.classList.add("mini-dot");
    mini.style.left = centerX + Math.sin(rad) * radius + "px";
    mini.style.top = centerY - Math.cos(rad) * radius + "px";
    container.appendChild(mini);

    allDots.push({ el: mini, angle: angleDeg, size: 5, type: "mini", text: null });
  }
}

allDots.sort((a, b) => a.angle - b.angle);

let detached = Array(allDots.length).fill(false);

// ✅ hand tip strictly at given angle
function getHandTipPosition(angle) {
  const scaleY = gsap.getProperty(hand, "scaleY");
  const effectiveLength = totalHeight * scaleY;
  const rad = angle * Math.PI / 180;
  return {
    x: centerX + Math.sin(rad) * effectiveLength,
    y: centerY - Math.cos(rad) * effectiveLength
  };
}

function updateHandLength() {
  const piecesDropped = allDots
    .map((d, j) => detached[j] ? d.size : 0)
    .reduce((a, b) => a + b, 0);
  gsap.to(hand, {
    scaleY: (totalHeight - piecesDropped)/totalHeight,
    duration: 0.3
  });
}

// --- helpers ---
function detachDot(dotObj, i) {
  detached[i] = true;
  const tip = getHandTipPosition(dotObj.angle);

  const dotRect = dotObj.el.getBoundingClientRect();
  const contRect = container.getBoundingClientRect();
  const targetX = dotRect.left - contRect.left + dotObj.el.offsetWidth/2;
  const targetY = dotRect.top - contRect.top + dotObj.el.offsetHeight/2;

  const dx = targetX - tip.x;
  const dy = targetY - tip.y;
  const dist = Math.sqrt(dx*dx + dy*dy);

  // prevent top dot showing at start
  if (dist < 1) {
    if (dotObj.angle === 0) return;
    gsap.set(dotObj.el, {opacity: 1});
    if (dotObj.text) gsap.to(dotObj.text, {opacity: 1, duration: 0.8});
    return;
  }

  const piece = document.createElement("div");
  piece.classList.add(dotObj.type === "main" ? "floating-piece-main" : "floating-piece-mini");
  piece.style.width = dotObj.size + "px";
  piece.style.height = dotObj.size + "px";
  piece.style.left = tip.x + "px";
  piece.style.top = tip.y + "px";
  container.appendChild(piece);

  gsap.to(piece, {
    x: dx,
    y: dy,
    duration: 0.8,
    ease: "power2.out",
    onComplete: () => {
      gsap.set(dotObj.el, {opacity: 1});
      piece.remove();
    }
  });

  updateHandLength();
  if (dotObj.text) gsap.to(dotObj.text, {opacity: 1, duration: 0.8});
}

function reattachDot(dotObj, i) {
  detached[i] = false;
  const tip = getHandTipPosition(dotObj.angle);

  const dotRect = dotObj.el.getBoundingClientRect();
  const contRect = container.getBoundingClientRect();
  const dotX = dotRect.left - contRect.left + dotObj.el.offsetWidth/2;
  const dotY = dotRect.top - contRect.top + dotObj.el.offsetHeight/2;

  const piece = document.createElement("div");
  piece.classList.add(dotObj.type === "main" ? "floating-piece-main" : "floating-piece-mini");
  piece.style.width = dotObj.size + "px";
  piece.style.height = dotObj.size + "px";
  piece.style.left = dotX + "px";
  piece.style.top = dotY + "px";
  container.appendChild(piece);

  gsap.set(dotObj.el, {opacity: 0});
  if (dotObj.text) gsap.to(dotObj.text, {opacity: 0, duration: 0.3});

  gsap.to(piece, {
    x: tip.x - dotX,
    y: tip.y - dotY,
    duration: 0.2,
    ease: "power2.in",
    onComplete: () => {
      piece.remove();
    }
  });

  updateHandLength();
}

// --- timeline + crossing detection ---
let lastAngle = 0;

const tl = gsap.timeline({
  scrollTrigger: {
    trigger: ".section",
    start: "top top",
    end: "+=4000",
    scrub: true,
    pin: true
  },
  onUpdate: () => {
    const transform = window.getComputedStyle(hand).transform;
    if (transform !== "none") {
      const values = transform.split("(")[1].split(")")[0].split(",");
      const a = parseFloat(values[0]), b = parseFloat(values[1]);
      let angle = Math.atan2(b, a) * (180 / Math.PI);
      if (angle < 0) angle += 360;

      const scrollingForward = (angle - lastAngle + 360) % 360 < 180;

      allDots.forEach((dotObj, i) => {
        if (!detached[i] && scrollingForward) {
          if (dotObj.angle === 0) {
            if (lastAngle < 1 && angle >= 1) detachDot(dotObj, i);
          } else if (lastAngle < dotObj.angle && angle >= dotObj.angle) {
            detachDot(dotObj, i);
          }
        }
        if (detached[i] && !scrollingForward) {
          if (dotObj.angle === 0) {
            if (lastAngle > 1 && angle < 1) reattachDot(dotObj, i);
          } else if (lastAngle > dotObj.angle && angle <= dotObj.angle) {
            reattachDot(dotObj, i);
          }
        }
      });

      lastAngle = angle;
    }
  }
});

// rotate hand full circle
tl.to(hand, { rotate: 360, duration: 1, ease: "none" });
</script>
</body>
</html>
